<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../temp/backbone.rebar.js - Backbone.Rebar</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../rebar.png" title="Backbone.Rebar"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Rebar.Application.html">Rebar.Application</a></li>
            
                <li><a href="../classes/Rebar.CompositeView.html">Rebar.CompositeView</a></li>
            
                <li><a href="../classes/Rebar.Controller.html">Rebar.Controller</a></li>
            
                <li><a href="../classes/Rebar.DependencyRouter.html">Rebar.DependencyRouter</a></li>
            
                <li><a href="../classes/Rebar.Logger.html">Rebar.Logger</a></li>
            
                <li><a href="../classes/Rebar.Mediator.html">Rebar.Mediator</a></li>
            
                <li><a href="../classes/Rebar.PersistenceModel.html">Rebar.PersistenceModel</a></li>
            
                <li><a href="../classes/Rebar.View.html">Rebar.View</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../temp/backbone.rebar.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(Backbone, _, $) {
    &#x27;use strict&#x27;;
    /**
     * @namespace Rebar
     */
    var Rebar = this.Rebar = Backbone.Rebar = {};
    // =======================================================================
    // === Pollyfills ========================================================
    // =======================================================================
    // @TODO work in ability to use two args
    if (!Object.create) {
        Object.create = function(o) {
            if (arguments.length &gt; 1) {
                throw new Error(&#x27;Object.create implementation only accepts the first parameter.&#x27;);
            }

            function F() {}
            F.prototype = o;
            return new F();
        };
    }
    // =======================================================================
    // === Helpers ===========================================================
    // =======================================================================
    /**
     * Extention functionality for the prototyped object that implements it.
     * @method extend
     * @param {Object} protoProps
     * @return {Object} child
     */
    var extend = function(protoProps) {
        var parent = this;
        var child = function() {
            parent.apply(this, arguments);
        };
        child.prototype = _.extend(parent.prototype, protoProps);
        return child;
    };
    // =======================================================================
    // === Application =======================================================
    // =======================================================================
    /**
     * The application shell provides a simple default architecture consisting of a model,
     * view and controller. The application is a singleton class in that there can only be one.
     * It extends &#x60;Backbone.Events&#x60; and you can see the [documentation](http://backbonejs.org/#Events)
     * for more detailed information.
     * @class Application
     * @constructor
     * @extends Backbone.Events
     * @uses extend
     * @example
     *	var appConfig = {
     *		...
     *	};
     *	var app = new Backbone.Rebar.Application(appConfig);
     *	app.on(&quot;applicationStateChange&quot;,function(state){
     *		...
     *	});
     *	app.startup();
     */
    var Application = Rebar.Application = function(options) {
        // singleton functionality
        if (Application.instance &amp;&amp; options &amp;&amp; !options._bypassSingleton) {
            return Application.instance;
        }
        if (options &amp;&amp; options.logLevel) {
            Logger.setLogLevel(options.logLevel);
        } else {
            Logger.setLogLevel(Logger.Levels.None);
        }
        Application.instance = this;
        this.options = options ? options : {};
        this.state = Application.States.Initialized;
        // setup listener for app shutdown
        $(window).on(&#x27;beforeunload unload&#x27;, $.proxy(function(e) {
            this.state = Application.States.Shutdown;
        }, this));
    };
    /**
     * Available states for the application used to describe the current state of the Application.
     * @property States
     * @type Object
     * @for Application
     * @final
     */
    Application.States = {
        Default: 0,
        Initialized: 1,
        Faulted: 2,
        Started: 3,
        Shutdown: 4
    };
    Application.prototype = Object.create(Backbone.Events, {
        /**
         * The current state value.
         * @property _state
         * @type Integer
         * @for Application
         * @private
         */
        _state: {
            value: Application.States.Default,
            writable: true
        },
        /**
         * Getters and setters for the current state value.
         * @property state
         * @type Integer
         * @for Application
         */
        state: {
            get: function() {
                return this._state;
            },
            set: function(state) {
                if (this._state === state) {
                    return;
                }
                this._state = state;
                if (this._state === Application.States.Initialized) {
                    if (_.isFunction(this.createModel)) {
                        this.createModel(this.options.modelOptions);
                    }
                    if (_.isFunction(this.createController)) {
                        this.createController(this.options.controllerOptions);
                    }
                    if (_.isFunction(this.createView)) {
                        this.createView(this.options.viewOptions);
                    }
                    if (_.isFunction(this.createRouter)) {
                        this.createRouter(this.options.routerOptions);
                    }
                    this.initialize(this.options);
                }
                this.trigger(&#x27;applicationStateDidChange&#x27;, this.state);
            }
        },
        /**
         * Initialization functionality for extended Application instances.
         * @method initialize
         * @for Application
         */
        initialize: {
            value: function(options) {},
            writable: true
        },
        /**
         * Create a model instance for the Application instance.
         * @method createModel
         * @for Application
         */
        createModel: {
            value: function(modelOptions) {
                if (!this.model) {
                    this.model = new Backbone.Model(_.extend({}, modelOptions));
                }
            },
            writable: true
        },
        /**
         * Create a view instance for the Application instance.
         * @method createView
         * @for Application
         */
        createView: {
            value: function(viewOptions) {
                if (!this.view) {
                    this.view = new CompositeView(_.extend({
                        el: $(&#x27;#application&#x27;),
                        model: this.model,
                        controller: this.controller
                    }, viewOptions));
                }
            },
            writable: true
        },
        /**
         * Create a controller instance for the Application instance.
         * @method createController
         * @for Application
         */
        createController: {
            value: function(controllerOptions) {
                if (!this.controller) {
                    this.controller = new Controller(_.extend({
                        model: this.model
                    }, controllerOptions));
                }
            },
            writable: true
        },
        /**
         * Create a dependency router instance for the Application instance.
         * @method createRouter
         * @for Application
         */
        createRouter: {
            value: function(routerOptions) {
                if (!this.router) {
                    this.router = new DependencyRouter(_.extend({
                        landing: this.options.landing ? this.options.landing : &#x27;&#x27;,
                        dispatcher: this
                    }, routerOptions));
                    this.router.on(&#x27;routeDidChange&#x27;, function(route) {
                        this.trigger(&#x27;routeDidChange&#x27;, route);
                    }, this);
                }
            },
            writable: true
        },
        /**
         * This method kicks off Backbone&#x27;s history managment as well as loads the bootstrap data
         * if a reference was passed through the contructors options argument.
         * @method startup
         * @for Application
         */
        startup: {
            value: function() {
                if (this.options.bootstrap) {
                    var delegate = this;
                    $.ajax({
                        cache: false,
                        dataType: &#x27;json&#x27;,
                        type: &#x27;GET&#x27;,
                        url: this.options.bootstrap,
                        success: function(response) {
                            if (!_.isEmpty(response)) {
                                delegate.model.set(&#x27;bootstrap&#x27;, response);
                                Backbone.history.start({
                                    pushState: false
                                });
                                delegate.state = Application.States.Started;
                            } else {
                                delegate.error = &#x27;Error: Bootstrap load error.&#x27;;
                                delegate.state = Application.States.Faulted;
                            }
                        },
                        error: function(error) {
                            delegate.error = error;
                            delegate.state = Application.States.Faulted;
                        }
                    });
                } else {
                    Backbone.history.start({
                        pushState: false
                    });
                    this.state = Application.States.Started;
                }
            }
        }
    });
    Application.extend = extend;
    // =======================================================================
    // === Persistence Model =================================================
    // =======================================================================
    /**
     * The &#x60;PeristenceModel&#x60; extends the basic [Backbone.Model](http://backbonejs.org/#Model)
     * and overwrites its sync method to take advantage of local storage and persist data
     * across multiple pages within the same domain. The url property is used to grab data
     * from a specific object of the localStorage object. Use the &#x60;fetch&#x60; method to pull
     * whatever data already exists in localStorage and use the &#x60;save&#x60; method to store for
     * later use.
     * @class PersistenceModel
     * @extends Backbone.Model
     * @constructor
     * @example
     *	var model = new Backbone.Rebar.PersistenceModel({
     *		url:&quot;custom&quot;
     *	});
     *	model.fetch();
     *	model.set(&quot;foo&quot;,&quot;bar&quot;);
     *	model.save();
     */
    var PersistenceModel = Rebar.PersistenceModel = Backbone.Model.extend({
        /**
         * Determains and returns a storage id based on the passed id in initialization
         * @method getStoargeId
         * @return {String} storage id for this persistence model
         * @private
         */
        getStoargeId: function() {
            var id = &#x27;pm&#x27;;
            if (this.urlRoot) {
                // for right now lets just keep this simple
                // @TODO: support ids with urlRoots
                id = id + &#x27;_&#x27; + this.url().split(&#x27;/&#x27;)[0];
            }
            return id;
        },
        /**
         * Overriden to make sure that we have a urlRoot on our persistence model
         * @method set
         * @param {Object} key
         * @param {Object} val
         * @param {Object} options
         */
        set: function(key, val, options) {
            if (key === &#x27;url&#x27;) {
                this.urlRoot = val;
            } else if (_.isObject(key) &amp;&amp; _.has(key, &#x27;url&#x27;) &amp;&amp; !_.isUndefined(key.url)) {
                this.urlRoot = key.url;
            }
            Backbone.Model.prototype.set.call(this, key, val, options);
        },
        /**
         * Overridden to reroute the to a localStorage endpoint.
         * @method sync
         * @param {String} method
         * @param {PersistenceModel} model
         * @param {Object} options
         * @private
         */
        sync: function(method, model, options) {
            if (method === &#x27;read&#x27;) {
                try {
                    this.pullLocalStore(model, options);
                } catch (e) {
                    console.error(&quot;Error reading from local store &quot; + model.getStoargeId(), e);
                }
            } else if (method === &#x27;create&#x27;) {
                var item;
                try {
                    var filteredObj = _.omit(model.attributes, [&#x27;url&#x27;, &#x27;urlRoot&#x27;]);
                    item = JSON.stringify(filteredObj);
                } catch (e) {
                    console.error(&quot;Error writing item to local store &quot; + model.getStoargeId(), e);
                }
                localStorage.setItem(model.getStoargeId(), item);
            } else if (method === &#x27;update&#x27;) {
                try {
                    this.pullLocalStore(model, options);
                } catch (e) {
                    console.error(&quot;Error updating model from local store &quot; + model.getStoargeId(), e);
                }
            } else if (method === &#x27;patch&#x27;) {
                throw &#x27;\&#x27;patch\&#x27; not implemented yet&#x27;;
            } else if (method === &#x27;delete&#x27;) {
                throw &#x27;\&#x27;delete\&#x27; not implemented yet&#x27;;
            }
        },
        /**
         * Helper method pulls data based on urlRoot from local storage
         * @method pullLocalStore
         * @param {PersistenceModel} model
         * @param {Object} options
         * @private
         */
        pullLocalStore: function(model, options) {
            if (localStorage) {
                var data = localStorage.getItem(model.getStoargeId());
                if (data !== null) {
                    var parsedData = JSON.parse(data);
                    model.set(parsedData);
                    // @TODO: Do i need the following 3 lines anymore ???
                    //if (options.success) {
                    //	options.success(model, parsedData, options);
                    //}
                    model.trigger(&#x27;sync&#x27;, model, parsedData, options);
                }
            } else {
                var error = &#x27;Error: \&#x27;localStorage\&#x27; is not supported&#x27;;
                if (options.error) {
                    options.error(model, error, options);
                }
                model.trigger(&#x27;sync&#x27;, model, error, options);
            }
        }
    });
    // =======================================================================
    // === View ==============================================================
    // =======================================================================
    /**
     * Base class that extends [Backbone.View](http://backbonejs.org/#View) and
     * provides boilerplate plate functionality for transitioning in and out, destroying
     * and rendering views.
     * @class View
     * @constructor
     * @extends Backbone.View
     * @example
     *	var view = new Backbone.Rebar.View({
     *		...
     *	});
     *	view.transitionIn({
     *		...
     *	});
     *	view.transitionOut({
     *		this.destroy();
     *	},this);
     */
    var View = Rebar.View = function(options) {
        Backbone.View.call(this, options);
        _.extend(this, _.pick(this.options, [&#x27;render&#x27;, &#x27;destroy&#x27;, &#x27;transitionIn&#x27;, &#x27;transitionOut&#x27;, &#x27;controller&#x27;]));
    };
    View.prototype = Object.create(Backbone.View.prototype, {
        /**
         * isDestroyed getter
         * @property isDestroyed
         * @type Boolean
         */
        isDestroyed: {
            get: function() {
                return _.isUndefined(this._isDestroyed) ? false : this._isDestroyed;
            }
        },
        /**
         * Reference to the views controller
         * @property controller
         * @type Controller
         */
        controller: {
            value: undefined,
            writable: true
        },
        /**
         * This method is a great helper method to call when the subclass view is about to be removed.
         * It recursively will call destroy on any subviews reference in the sub views array. It also handles
         * removing any event listeners that may have been added to the subViews array.
         * @method destroy
         */
        destroy: {
            value: function() {
                if (!this._isDestroyed) {
                    this._isDestroyed = true;
                    this.trigger(&#x27;viewDidDestroy&#x27;, this);
                    this.off();
                    this.$el.off();
                    this.remove();
                }
            },
            writable: true
        },
        /**
         * For instances that are used in dependency routing the render method is called
         * and used directly after loading. For all other uses you must call render manually.
         * @method render
         * @param {Function} callback
         */
        render: {
            value: function(callback) {
                // ...
            },
            writable: true
        },
        /**
         * Transitions in the view. By default this method actually does nothing.
         * @method transitionIn
         * @param {Function} callback
         */
        transitionIn: {
            value: function(callback, context) {
                if (_.isFunction(callback)) {
                    callback.call(context ? context : this);
                }
            },
            writable: true
        },
        /**
         * Transitions out the view. By default this method actually does nothing.
         * @method transitionOut
         * @param {Function} callback
         */
        transitionOut: {
            value: function(callback, context) {
                if (_.isFunction(callback)) {
                    callback.call(context ? context : this);
                }
            },
            writable: true
        }
    });
    View.extend = Backbone.View.extend;
    // =======================================================================
    // === Composite View ====================================================
    // =======================================================================
    /**
     * Most of the time Backbone views need to be able to contain other views. When you do this you run
     * into situations where you need to add the view then render and when you go to destroy the parent
     * view, you want to make sure you properly dispose of its children.
     * The composite view makes managing child parent relationships a bit easier by adding recursive destroy
     * functionality as well as making it possible to quickly add and remove child views.
     * @class CompositeView
     * @extends View
     * @constructor
     * @example
     *	var composite = new Backbone.Rebar.CompositeView({
     *		...
     *	});
     *	var view = new Backbone.Rebar.View({
     *		...
     *	});
     *	composite.addSubView(view);
     */
    var CompositeView = Rebar.CompositeView = function(options) {
        this.subViews = [];
        View.call(this, options);
        //_.extend(this, _.pick(this.options, [&#x27;addSubView&#x27;, &#x27;removeSubView&#x27;, &#x27;removeAllSubViews&#x27;, &#x27;destroy&#x27;]));
    };
    CompositeView.prototype = Object.create(View.prototype, {
        /**
         * Adds a sub view to a container BaseView
         * @method addSubView
         * @param {View} view
         */
        addSubView: {
            value: function(view) {
                // add event listeners for view
                view.on(&#x27;viewDidDestroy&#x27;, function(view) {
                    this.removeSubView(view);
                }, this);
                // add sub view
                this.subViews.push(view);
                // render subview
                var delegate = this;
                view.render(function(el) {
                    var markup = el ? el : view.el;
                    delegate.$el.append(markup);
                });
                // @TODO - possibly trigger view has been added
            },
            writable: true
        },
        /**
         * Adds an array of sub views to a container BaseView
         * @method addSubViews
         * @param {Array} views Array of subviews
         */
        addSubViews: {
            value: function(views) {
                _.each(views, function(view) {
                    this.addSubView(view);
                }, this);
            },
            writable: true
        },
        /**
         * Removes a sub view from the container view
         * @method removeSubView
         * @param {Object} view A base view or a cid of the sub view
         */
        removeSubView: {
            value: function(view) {
                // assuming that what was passed was not an actual view and in fact was a cid
                if (!view.cid) {
                    view = _.where(this.subViews, {
                        cid: view
                    })[0];
                }
                this.destroySubView(view);
                this.subViews = _.reject(this.subViews, function(subView) {
                    return subView.cid === view.cid;
                });
            },
            writable: true
        },
        /**
         * Removes all sub views from view
         * @method removeAllSubViews
         */
        removeAllSubViews: {
            value: function() {
                _.each(this.subViews, function(view) {
                    this.removeSubView(view);
                }, this);
            },
            writable: true
        },
        /**
         * This method is a great helper method to call when the subclass view is about to be removed.
         * It recursively will call destroy on any subviews reference in the sub views array. It also handles
         * removing any event listeners that may have been added to the subViews array.
         * @method destroy
         */
        destroy: {
            value: function() {
                // recursively destroy sub views
                if (this.subViews.length &gt; 0) {
                    _.each(this.subViews, function(view) {
                        this.destroySubView(view);
                    }, this);
                }
                this.subViews = [];
                View.prototype.destroy.call(this);
            },
            writable: true
        },
        /**
         * Checks to see if the passed view has destroy functionality and then if it does not
         * calls the prototype destroy functionality and passes the reference
         * @method destroySubView
         * @param {View} view
         * @private
         */
        destroySubView: {
            value: function(view) {
                if (_.isFunction(view.destroy) &amp;&amp; !view.isDestroyed) {
                    view.destroy(true);
                } else {
                    if (!_.isUndefined(view.cid)) {
                        View.prototype.destroy.call(view);
                    }
                }
            },
            writable: true
        }
    });
    CompositeView.extend = View.extend;
    // =======================================================================
    // === Mediator ==========================================================
    // =======================================================================
    /**
     * Simple implementation of the [mediator pattern](http://en.wikipedia.org/wiki/Mediator_pattern) for use with Backbone.Views
     * @class Mediator
     * @constructor
     * @uses extend
     * @example
     *	var mediator = new Mediator({
     *		events:{
     *			&quot;appwide1&quot;:{
     *				dispatcher:app
     *				callback:&quot;method&quot;
     *			}
     *		},
     *		initialize:function(options){
     *			...
     *		},
     *		method:function(e){
     *			...
     *		},
     *		handle:function(eventName,module){
     *			...
     *		}
     *	});
     *	mediator.addView(view,&quot;event1 event2&quot;);
     *	view.trigger(&quot;something&quot;,view);
     *	mediator.removeView(view);
     */
    var Mediator = Rebar.Mediator = function(options) {
        if (options) {
            this.options = options;
            _.extend(this, _.pick(this.options, [&#x27;initialize&#x27;, &#x27;handle&#x27;, &#x27;view&#x27;]));
            if (this.options.events) {
                this.processEvents(this.options.events);
            }
            if (this.view &amp;&amp; this.options.viewEvents) {
                this.processViewEvents(this.options.viewEvents);
            }
        }
        this._views = [];
        this.initialize(options);
    };
    Mediator.prototype = Object.create(Backbone.Events, {
        /**
         * Stores reference to all views added to the mediator.
         * @property _views
         * @type Array
         * @for Mediator
         * @private
         */
        _views: {
            value: undefined,
            writable: true,
            configurable: false
        },
        /**
         * Reference to a single view who we&#x27;ll be mediating for.
         * @property view
         * @type Backbone.View
         * @for Mediator
         */
        view: {
            value: undefined,
            writable: true,
            configurable: false
        },
        /**
         * Called for any modules that extend the &#x60;Mediator&#x60; prototype.
         * @method initialize
         * @for Mediator
         */
        initialize: {
            value: function(options) {},
            writable: true
        },
        /**
         * Adds module as one that the mediator should be listening for events.
         * @method addView
         * @for Mediator
         * @param {Backbone.View} view
         * @param {String} eventNames
         */
        addView: {
            value: function(view, eventNames) {
                var events;
                if (eventNames) {
                    events = eventNames.split(&#x27; &#x27;);
                } else {
                    events = [&#x27;all&#x27;];
                }
                _.each(events, function(eventName) {
                    view.on(eventName, function(options) {
                        this.handle(eventName, view, options);
                    }, this);
                }, this);
                this._views.push(view);
            },
            writable: true
        },
        /**
         * Removes module from one that the mediator should be listening for.
         * @method removeView
         * @for Mediator
         * @param {Backbone.View} view
         */
        removeView: {
            value: function(view) {
                // @TODO: remove all events that the view has with this handler
                view.off(null, this.handle, this);
                this._views = _.reject(this._views, function(v) {
                    if (v.cid === view.cid) {
                        return true;
                    }
                    return false;
                }, this);
            },
            writable: true
        },
        /**
         * Returns boolean for whether the mediator contains a view or not.
         * @method hasView
         * @for Mediator
         * @param {Backbone.View} view
         */
        hasView: {
            value: function(view) {
                return _.where(this._views, {
                    cid: view.cid
                })[0];
            },
            writable: true
        },
        /**
         * Returns a view that has the same value/key pairs provided
         * @method getView
         * @for Mediator
         * @param {Object} attribute Key/Value pair to use with an UnderscoreJS _.with look up
         * @example
         *	...
         *	mediator.getView({name:&quot;foo&quot;});
         */
        getView: {
            value: function(attribute) {
                return _.filter(this._views, function(view) {
                    var key = _.keys(attribute)[0];
                    var value = _.values(attribute)[0];
                    if (view[key] &amp;&amp; view[key] === value) {
                        return true;
                    } else if (view.options &amp;&amp; view.options[key] &amp;&amp; view.options[key] === value) {
                        return true;
                    }
                    return false;
                })[0];
            },
            writable: true
        },
        /**
         * Returns a view that has the same **user defined** name provided
         * @method getViewByName
         * @for Mediator
         * @param {String} name User defined view name
         * @example
         *	...
         *	mediator.getView({name:&quot;foo&quot;});
         */
        getViewByName: {
            value: function(name) {
                var view = this.getView({
                    name: name
                });
                if (_.isUndefined(view)) {
                    console.warn(&#x27;Property \&#x27;name\&#x27; was not found on any views.&#x27;);
                }
                return view;
            },
            writable: true
        },
        /**
         * destroys a mediator and removes all listeners.
         * @method destroy
         * @for Mediator
         */
        destroy: {
            value: function() {
                _.each(this._views, function(view) {
                    this.removeView(view);
                }, this);
            },
            writable: true
        },
        /**
         * Handler method that is called when one of the module the mediator is listening
         * for is fired. Should be overriden in &#x60;Mediator&#x60; instances.
         * @method handle
         * @for Mediator
         * @param {Object} eventName
         * @param {Object} module
         */
        handle: {
            value: function(eventName, view) {},
            writable: true
        },
        /**
         * Runs through all of the events that the mediator should be listening for.
         * @method processEvents
         * @for Mediator
         * @param {Object} events
         * @private
         */
        processEvents: {
            value: function(events) {
                for (var item in events) {
                    var eventObj = events[item];
                    if (_.isObject(eventObj)) {
                        this.assignCallbackToDispatcher(item, eventObj.callback, eventObj.dispatcher);
                    } else {
                        this.assignCallbackToDispatcher(item, eventObj, this.options.dispatcher);
                    }
                }
            }
        },
        /**
         * Processes all of the viewEvents passes in through the mediator config options
         * @method processViewEvents
         * @for Mediator
         * @param {String} events
         * @private
         */
        processViewEvents: {
            value: function(events) {
                var eventsArr = events.split(&quot; &quot;);
                _.each(eventsArr, function(event, index) {
                    this.view.on(event.toString(), function(options) {
                        this.handle(event, this.view, options);
                    }, this);
                }, this);
            }
        },
        /**
         * Assigns a callback to the passed dispatcher for the event to be fired.
         * @method assignCallbackToDispatcher
         * @for Mediator
         * @param {String} eventName
         * @param {String} callbackName
         * @param {Object} dispatcher
         * @private
         */
        assignCallbackToDispatcher: {
            value: function(eventName, callbackName, dispatcher) {
                if (this[callbackName]) {
                    dispatcher.on(eventName, this[callbackName], this);
                } else if (this.options[callbackName]) {
                    dispatcher.on(eventName, this.options[callbackName], this);
                } else {
                    console.error(&#x27;Error: No method \&#x27;&#x27; + callbackName + &#x27;\&#x27; found on mediator&#x27;);
                }
            }
        }
    });
    Mediator.extend = extend;
    // =======================================================================
    // === Controller ========================================================
    // =======================================================================
    /**
     * Simple controller object.
     * @class Controller
     * @constructor
     * @extends Backbone.Events
     * @uses extend
     * @TODO Determine what other functionality needs to be a part of the controller.
     */
    var Controller = Rebar.Controller = function(options) {
        if (!_.isUndefined(options)) {
            this.options = options;
            _.extend(this, _.pick(this.options, [&#x27;model&#x27;]));
        }
    };
    Controller.prototype = Object.create(Backbone.Events, {
        /**
         * Reference to the model the controller will be interacting with
         * @property model
         * @type Backbone.Model
         */
        model: {
            value: undefined,
            writable: true
        }
    });
    Controller.extend = extend;
    // =======================================================================
    // === Dependency Router =================================================
    // =======================================================================
    /**
     * Handles all pre and post routing functionality. This is the default router when you initialize
     * an &#x60;Application&#x60; instance. Once initialized any time the browser&#x27;s anchor location changes this
     * class notifies the rest of the application of the new directory, file, view and anchor to use.
     * To use simply listen to the application&#x27;s &#x60;routeDidChange&#x60; or the router&#x27;s &#x60;routeDidChange&#x60; event firing
     * and then implement the AMD loader that makes the most sense (for your project) to use.
     * @class DependencyRouter
     * @extends Backbone.Router
     * @constructor
     * @example
     *	// requirejs example
     *	router.on(&quot;routeDidChange&quot;, function(route){
     *		var mReq = require([resource], function(a) {
     *			var Constructor = a[view];
     *			var v = new Constructor({
     *				routeData: data
     *			});
     *			delegate.addSubView(v);
     *		}, function(e) {
     *			console.log(&quot;Error: &quot; + e);
     *		});
     *	});
     */
    var DependencyRouter = Rebar.DependencyRouter = function(options) {
        if (!_.isUndefined(options)) {
            if (!_.isUndefined(options.landing)) {
                this.landing = options.landing;
            }
            if (!_.isUndefined(options.staticRoutes)) {
                for (var route in options.staticRoutes) {
                    this.setStaticRoute(route, options.staticRoutes[route]);
                }
            }
        }
        Backbone.Router.call(this, options);
    };
    DependencyRouter.prototype = Object.create(Backbone.Router.prototype, {
        /**
         * Default landing for no hash. Where the browser will be routed to when landing
         * on the root url of the applicaiton.
         * @property landing
         * @type {String}
         * @default &quot;&quot;
         */
        landing: {
            value: &#x27;&#x27;,
            writable: true
        },
        /**
         * Define only the route hash here because we&#x27;ll be using dependency routing
         * for the rest of the functionality.
         * @property routes
         * @type {Object} route key value pairs
         * @default { &quot;&quot;: &quot;handleNoHash&quot;, &quot;*splat&quot;: &quot;handleAll&quot; }
         * @private
         */
        routes: {
            value: {
                &#x27;&#x27;: &#x27;handleNoHash&#x27;,
                &#x27;*splat&#x27;: &#x27;handleAll&#x27;
            },
            writable: true
        },
        /**
         * This object is empty by default, but routes added here, either manually,
         * or through the two methods, setStaticRoute and setStaticRoutes, will bypass
         * the handleAll and handleNoHash methods referenced in the routes object.
         * @property staticRoutes
         * @type {Object} static route key value pairs
         * @private
         */
        staticRoutes: {
            value: {},
            writable: true
        },
        /**
         * Reroute the page to the page referenced as landing
         * @method handleNoHash
         * @private
         */
        handleNoHash: {
            value: function() {
                this.handleAll(this.landing + Backbone.history.location.search);
            },
            writable: true
        },
        /**
         * Handles every route that doesnt match any of the previous matches
         * @method handleAll
         * @private
         */
        handleAll: {
            value: function(route) {
                // reference the current url from backbone
                var routeString = _.isUndefined(route) ? Backbone.history.getFragment() : route;
                // check to make sure we dont have any static routes that were added
                for (var sRoute in this.staticRoutes) {
                    if (sRoute === routeString) {
                        this.staticRoutes[sRoute]();
                        return;
                    }
                }
                var pRoute = this.parseRoute(routeString);
                // now that we&#x27;re sure that the current route is not one of the static routes set
                // then we&#x27;ll move forward with the dependency routing functionality
                this.trigger(&#x27;routeDidChange&#x27;, pRoute);
                this.pRoute = pRoute;
            },
            writable: true
        },
        /**
         * Parses a passed route string and determines directory, file, view and data
         * @method parseRoute
         * @param {String} route The current Backbone.history fragment
         * @private
         */
        parseRoute: {
            value: function(route) {
                var hash = route.split(&#x27;/&#x27;);
                var directory;
                var file;
                // define view and data
                var splitView = hash[hash.length - 1].split(&#x27;?&#x27;);
                // figure out view and anchor
                var viewParts = splitView[0].split(&#x27;#&#x27;);
                var view = viewParts[0];
                var anchor = route.split(&#x27;#&#x27;)[1];
                var data = this.parseRouteData(splitView[1]);
                // if only two parts are passed then we should assume that there is no directory and the two parts
                // are the file reference and the view reference is the view to instantiate
                if (hash.length === 2) {
                    file = hash[0];
                }
                // this is the default behavior, 3 parts, directory, file and view
                if (hash.length === 3) {
                    directory = hash[0];
                    file = hash[1];
                }
                // here we&#x27;re going to take everything before the last two parts of the has and concider them
                // to be directories
                if (hash.length &gt; 3) {
                    var dirLength = hash.length - 2;
                    directory = &#x27;&#x27;;
                    for (var i = 0; i &lt; dirLength; i++) {
                        directory += hash[i] + (i &lt; dirLength - 1 ? &#x27;/&#x27; : &#x27;&#x27;);
                    }
                    file = hash[hash.length - 2];
                }
                return {
                    directory: directory,
                    file: file,
                    view: view !== &#x27;&#x27; ? view : undefined,
                    data: data,
                    anchor: anchor
                };
            },
            writable: true
        },
        /**
         * Parse the query string provides and returns key value pair object
         * @method parseRouteData
         * @param {String} query
         * @private
         */
        parseRouteData: {
            value: function(query) {
                if (_.isUndefined(query)) {
                    return undefined;
                }
                var vars = query.split(&#x27;&amp;&#x27;);
                var data = {};
                _.each(vars, function(v) {
                    var pair = v.split(&#x27;=&#x27;);
                    data[pair[0]] = pair[1];
                });
                return data;
            },
            writable: true
        },
        /**
         * Takes a passed route object and determains a file location
         * @method getFileLocation
         * @param {Object} route Object formed in parseRoute method
         * @private
         */
        getFileLocation: {
            value: function(route) {
                if (_.isUndefined(route.directory) || route.directory === &#x27;&#x27;) {
                    if (_.isUndefined(route.file) || route.file === &#x27;&#x27;) {
                        return &#x27;&#x27;;
                    }
                    return route.file;
                }
                return route.directory + &#x27;/&#x27; + route.file;
            },
            writable: true
        },
        /**
         * Adds the name and method to the staticRoutes object as a key/value pair
         * @method setStaticRoute
         * @param {String} name
         * @param {Function} method
         */
        setStaticRoute: {
            value: function(name, method) {
                this.staticRoutes[name] = method;
            },
            writable: true
        },
        /**
         * Takes key value pairs from an object and sets them to the staticRoutes
         * object on the router
         * @method setStaticRoutes
         * @param {Object} routes
         */
        setStaticRoutes: {
            value: function(routes) {
                for (var route in routes) {
                    this.staticRoutes[route] = routes[route];
                }
            },
            writable: true
        }
    });
    DependencyRouter.extend = Backbone.Router.extend;
    // =======================================================================
    // === Logger ============================================================
    // =======================================================================
    /**
     * Logger
     * @class Logger
     */
    var Logger = Rebar.Logger = (function() {
        var root = this;
        var _console = typeof(console) !== undefined;
        var _logLevel = 0;

        function log(msg) {
            if (_console &amp;&amp; _logLevel &gt;= Logger.Levels.Info) {
                root.console.log(msg);
            }
        }

        function warn(msg) {
            if (_console &amp;&amp; _logLevel &gt;= Logger.Levels.Info) {
                root.console.warn(msg);
            }
        }

        function error(msg) {
            if (_console &amp;&amp; _logLevel &gt;= Logger.Levels.Error) {
                root.console.error(msg);
            }
        }

        function setLogLevel(logLevel) {
            _logLevel = logLevel;
            return _logLevel;
        }
        return {
            /**
             * console.log wrapper
             * @method log
             * @param {Object} msg
             */
            log: log,
            /**
             * console.warn wrapper
             * @method warn
             * @param {Object} msg
             */
            warn: warn,
            /**
             * console.error wrapper
             * @method error
             * @param {Object} msg
             */
            error: error,
            /**
             * Sets the log level for the logger
             * @method setLogLevel
             * @param {Logger.Levels} logLevel
             */
            setLogLevel: setLogLevel,
            /**
             * Possible log levels to set the logger to
             * @property Levels
             * @static
             */
            Levels: {
                None: 0,
                Error: 10,
                Info: 20,
                Verbose: 30
            }
        };
    }).call(this);
}).call(this, Backbone, _, $);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
